# -*- coding: utf-8 -*-
"""HeartClassification_template_normal_resample_GELU.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FyhJa6aD9uohvh58afosHjrXiuicQ6fM
"""

#The Name Of The EXPERMENT // skip it if you just test the model
EXPERMENT_NAME = 'HeartClassificationTemplateFreeStyle2_GELU'

"""## Load Dataset"""

# connect to google Drive
from google.colab import drive
drive.mount('/content/drive')

# copy data mitbih dataset from google drive to colab
!cp /content/drive/MyDrive/FcaiBsuTeam/Software/Training/DataSet/mitbih.csv.zip /content/

!cp /content/drive/MyDrive/FcaiBsuTeam/Software/Training/DataSet/mitbih_test.csv /content/

# if you faced any problem in copy this data to your work enviroment here just uncomment these 2 line and run this cell
#!gdown 1HpF9h3ZQ7z9S7WK0APvZr9jf-J5ZfZD8
#!gdwon 1HbHfJYJq7YGXJdm-PeXRfcM830aY7Ass

"""### install dependencies"""

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# pip install pytorch-lightning
# pip install wandb
# pip install optuna

"""### Import Libs"""

import wandb
import pandas as pd
from pytorch_lightning.loggers import WandbLogger
import optuna
from optuna.integration import PyTorchLightningPruningCallback
from sklearn.model_selection import train_test_split

import pytorch_lightning as pl
import torch
import pandas as pd
import numpy as np
import torch.nn as nn
import torch.optim as optim
import torch.nn.functional as F

from torch.utils.data import Dataset , DataLoader
from sklearn.utils import shuffle

from pytorch_lightning.callbacks import ModelCheckpoint
from pytorch_lightning.callbacks.early_stopping import EarlyStopping

"""### wandb settings"""

# you need to use this accsess key below : 31880a10cc6e931ba2603689e6afb0ae48f3d0c1

!wandb login --relogin

wandb_logger = WandbLogger(project = "HeartClassification" , entity = "muhammed266")

"""### Define DataLoader"""

# here we define ECGDATASET DataSet Sampler
# that take csv file and return when calling __getitem__ datapoint ready to use in our model
class ECGDataset(Dataset):

    def __init__(self, df):
        self.df = df
        self.data_columns = self.df.columns[:-2].tolist()

    def __getitem__(self, idx):
        # we need to convert dtype of the data to float and the target to long
        # and all od them to torch Tensors
        signal = self.df.loc[idx, self.data_columns].astype('float32')
        signal = torch.FloatTensor([signal.values])
        target = torch.LongTensor(np.array(self.df.loc[idx, 'class']))
        return signal, target

    def __len__(self):
      return len(self.df)

# Here we

# 2 We also add some settings and values ​​such as batch size , test size

class dataloader(pl.LightningDataModule):
    def __init__(self , train_path , batch_size ):
        super().__init__()

        self.batch_size = batch_size
        self.train_path = train_path

    def prepare(self):
      # Devide ourdataset to train / validation
      # define (train data sampler , validation data) sampler
      df = pd.read_csv(self.train_path)
      train_df, val_df = train_test_split(df, test_size=0.15 , random_state=2021 ,  stratify=df['label'])

      self.train_df, self.val_df = train_df.reset_index(drop=True), val_df.reset_index(drop=True)

      self.train_dataset = ECGDataset(self.train_df)
      self.valid_dataset = ECGDataset(self.val_df)

    def train_dataloader(self):
        return DataLoader(self.train_dataset, batch_size = self.batch_size, shuffle=True)

    def val_dataloader(self):
        return DataLoader(self.valid_dataset , batch_size = self.batch_size )

data = dataloader("/content/mitbih.csv.zip" , 200)
data.prepare()

"""## Define The Model And Metaheuristic Optimization

![photo1657160423.jpeg](data:image/jpeg;base64,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)
"""

!pip install pyMetaheuristic

from pyMetaheuristic.algorithm  import arithmetic_optimization_algorithm
from pyMetaheuristic.utils import graphs

# define model with variable parameters

class  Model(pl.LightningModule):

    def __init__(self, num_of_class, lr, num_layer, dropout):
        super(Model, self).__init__()
        self.lr = lr
        self.model = nn.Sequential(
            nn.Conv1d(1, 32, kernel_size=3, stride=1 , padding = 1),
            nn.BatchNorm1d(32) ,
            nn.ReLU() ,

            nn.Conv1d(32 , 64 , kernel_size = 3 , stride = 1 , padding = 1) ,
            nn.BatchNorm1d(64) ,
            nn.ReLU() ,
            nn.MaxPool1d(3),

            nn.Conv1d(64 , 128 , kernel_size = 3 , stride = 1 , padding = 1) ,
            nn.BatchNorm1d(128) ,
            nn.ReLU() ,
            nn.MaxPool1d(3) ,

            nn.Conv1d(128 , 256 , kernel_size = 3 , stride = 1 , padding = 1) ,
            nn.BatchNorm1d(256) ,
            nn.ReLU() ,
            nn.Dropout(dropout))

        self.linear = nn.Sequential(
            nn.Linear(5120,int(num_layer)) ,
            nn.Dropout(dropout) ,
            nn.LeakyReLU(inplace = True) ,
            nn.Linear(int(num_layer) , num_of_class)
        )

    def forward(self,x):
        # x = x.unsqueeze(1)
        x = self.model(x)
        x = x.view(x.size(0), -1)
        x = self.linear(x)

        return x

    def configure_optimizers(self):
        return optim.AdamW(self.parameters(), lr = self.lr)

    def training_step(self , batch , batch_idx):
        src , trg = batch
        preds = self(src)
        loss  = F.cross_entropy(preds , trg)
        acc   = (preds.argmax(dim = -1) == trg).float().mean()

        self.log("train_acc" , acc , on_step = True , on_epoch = True , prog_bar = True , )
        self.log("train_loss" , loss , on_step = True , on_epoch = True , prog_bar = True)

        return loss

    def validation_step(self , batch , batch_idx):
        src , trg = batch
        preds = self(src)
        loss  = F.cross_entropy(preds , trg)
        acc   = (preds.argmax(dim = -1) == trg).float().mean()

        self.log("val_acc" , acc , on_step = True , on_epoch = True , prog_bar = True , )
        self.log("val_loss" , loss , on_step = True , on_epoch = True , prog_bar = True)

    def test_step(self , batch , batch_idx):
      src , trg = batch
      preds = self(src)
      loss  = F.cross_entropy(preds , trg)
      acc   = (preds.argmax(dim = -1) == trg).float().mean()
      self.log("test_acc" , acc , on_step = True , on_epoch = True , prog_bar = True , )
      self.log("test_loss" , loss , on_step = True , on_epoch = True , prog_bar = True)
      return {"loss" : loss ,
              "accuracy" : acc}

data = dataloader("/content/mitbih.csv.zip" , 96)
data.prepare()

# Target Function - It can be any function that needs to be minimize

num_classes = 5
def targetFunction(variables_values = [0, 0, 0]):
    lr, num_layer, dropout = variables_values
    model = Model(num_classes, lr, num_layer, dropout)
    trainer_CNN = pl.Trainer(log_every_n_steps = 1 , deterministic = True , gpus = 1 , max_epochs = 5 , fast_dev_run = False , logger = wandb_logger)
    trainer_CNN.fit(model, data)
    loss = trainer_CNN.logged_metrics['val_loss_epoch'].item()

    return loss

# AOA - Parameters
parameters = {
    'size': 10,
    'min_values': (0.00001, 32, 0.3),
    'max_values': (0.1, 512, 0.8),
    'iterations': 3,
    'alpha': 5,
    'mu': 0.5,
    'verbose': True
}

# AOA - Algorithm
aoa = arithmetic_optimization_algorithm(target_function = targetFunction, **parameters)

#Define The Model With Best Values From AOA Optimization
class  Model(pl.LightningModule):

    def __init__(self, num_of_class):
        super(Model, self).__init__()

        self.model = nn.Sequential(
            nn.Conv1d(1, 32, kernel_size=3, stride=1 , padding = 1),
            nn.BatchNorm1d(32) ,
            nn.GELU() ,

            nn.Conv1d(32 , 64 , kernel_size = 3 , stride = 1 , padding = 1) ,
            nn.BatchNorm1d(64) ,
            nn.GELU() ,
            nn.MaxPool1d(3),

            nn.Conv1d(64 , 128 , kernel_size = 3 , stride = 1 , padding = 1) ,
            nn.BatchNorm1d(128) ,
            nn.GELU() ,
            nn.MaxPool1d(3) ,

            nn.Conv1d(128 , 256 , kernel_size = 3 , stride = 1 , padding = 1) ,
            nn.BatchNorm1d(256) ,
            nn.GELU() ,
            nn.Dropout(0.6))

        self.linear = nn.Sequential(
            nn.Linear(5120,512) ,
            nn.Dropout(0.5) ,
            nn.LeakyReLU(inplace = True) ,
            nn.Linear(512 , num_of_class)
        )

    def forward(self,x):
        # x = x.unsqueeze(1)
        x = self.model(x)
        x = x.view(x.size(0), -1)
        x = self.linear(x)
        return x

    def configure_optimizers(self):
        # here we define the optimizer
        return optim.AdamW(self.parameters())

    def training_step(self , batch , batch_idx):
        # that descripe what happend in every training step
        src , trg = batch
        preds = self(src)
        # we calculate the loss and accuracy from here
        loss  = F.cross_entropy(preds , trg)
        acc   = (preds.argmax(dim = -1) == trg).float().mean()
        # add train accuracy and train loss to the logger we have (wand in our case)
        self.log("train_acc" , acc , on_step = True , on_epoch = True , prog_bar = True , )
        self.log("train_loss" , loss , on_step = True , on_epoch = True , prog_bar = True)
        return loss

    def validation_step(self , batch , batch_idx):
        # that descripe what happend in every training step
        src , trg = batch
        preds = self(src)
        loss  = F.cross_entropy(preds , trg)
        acc   = (preds.argmax(dim = -1) == trg).float().mean()
        # add validation accuracy and validation loss to the logger we have (wand in our case)
        self.log("val_acc" , acc , on_step = True , on_epoch = True , prog_bar = True , )
        self.log("val_loss" , loss , on_step = True , on_epoch = True , prog_bar = True)

    def test_step(self , batch , batch_idx):
      # thats how test step is gonna be working
      src , trg = batch
      preds = self(src)
      loss  = F.cross_entropy(preds , trg)
      acc   = (preds.argmax(dim = -1) == trg).float().mean()
      self.log("test_acc" , acc , on_step = True , on_epoch = True , prog_bar = True , )
      self.log("test_loss" , loss , on_step = True , on_epoch = True , prog_bar = True)
      return {"loss" : loss ,
              "accuracy" : acc}

model = Model(num_of_class = 5)

# lets display our layers here
model

"""### setup Trainer"""

# we add some checkpoints to our training to
checkpoint_callback = ModelCheckpoint(f"/content/drive/MyDrive/FcaiBsuTeam/Software/Training/ColabNoteBooks/{EXPERMENT_NAME}.ckpt", monitor = "val_loss" , mode = "min")
early_stopping = EarlyStopping(monitor = "val_loss" , patience = 30 , verbose = True , mode = "min")

# max_epochs refere to the number of epochs that used
# logger -> wandb logger that we used
# callbacks -> it's a list contains all  callbacks that we defined above (early stop and save parameters of the best values)
# we add some checkpoints to our training to
checkpoint_callback = ModelCheckpoint(f"/content/drive/MyDrive/FcaiBsuTeam/Software/Training/ColabNoteBooks/{EXPERMENT_NAME}.ckpt", monitor = "val_loss" , mode = "min")
early_stopping = EarlyStopping(monitor = "val_loss" , patience = 30 , verbose = True , mode = "min")
trainer_CNN = pl.Trainer(log_every_n_steps = 1 , deterministic = True , gpus = 1 , max_epochs = 100 , fast_dev_run = False , logger = wandb_logger  , callbacks = [
                                checkpoint_callback , early_stopping])

trainer_CNN.fit(model  , data)

trainer_CNN.save_checkpoint(f'model{EXPERMENT_NAME}.ckpt')

wandb.finish()

new_model = Model.load_from_checkpoint(checkpoint_path=f"/content/drive/MyDrive/FcaiBsuTeam/implementations/Training/Model Checkpoint/model.ckpt" , num_of_class = 5)

from sklearn.metrics import confusion_matrix

def cm_helper(model , dataloader):
  output  = []
  actual  = []
  for x , y in dataloader:
    preds = model(x)
    actual+= y.numpy().tolist()
    logits = preds.argmax(dim = -1)
    output+=logits.numpy().tolist()
  return actual , output

import itertools
import numpy as np
import matplotlib.pyplot as plt

def plot_confusion_matrix(cm, classes, normalize=False, title='Confusion matrix', cmap=plt.cm.Blues):
    if normalize:
        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
        print("Normalized confusion matrix")
    else:
        print('Confusion matrix, without normalization')

    print(cm)
    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation=45)
    plt.yticks(tick_marks, classes)

    fmt = '.2f' if normalize else 'd'
    thresh = cm.max() / 2.
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        plt.text(j, i, format(cm[i, j], fmt), horizontalalignment="center", color="white" if cm[i, j] > thresh else "black")

    plt.tight_layout()
    plt.ylabel('True label')
    plt.xlabel('Predicted label')

from sklearn.metrics import confusion_matrix , classification_report

class ECGDataset2(Dataset):

    def __init__(self, df):
        self.df = df
        self.data_columns = self.df.columns[:-1].tolist()

    def __getitem__(self, idx):
        # print(1)
        signal = self.df.iloc[idx, :-1].astype('float32')
        # print(2)
        signal = torch.FloatTensor([signal.values])
        # print(3)
        target = torch.LongTensor(np.array(self.df.iloc[idx, -1]))
        # print(4)
        return signal, target

    def __len__(self):
      return len(self.df)

test_df = pd.read_csv("/content/mitbih_test.csv" , names = [str(i) for i in range(188)])
print(test_df.shape)
test_dataset = ECGDataset2(test_df)
test_dataloader = DataLoader(dataset=test_dataset, batch_size=200, num_workers=0, shuffle=False)

test_result = trainer_CNN.test(new_model , test_dataloader)

actual , output = cm_helper(new_model , test_dataloader)
cm = confusion_matrix(actual, output, labels=[0 , 1 , 2 , 3 , 4])

cm

plot_confusion_matrix(cm , classes = [0 , 1 , 2 , 3 , 4])

from sklearn.metrics import confusion_matrix , classification_report
print(classification_report(y_true=actual ,y_pred=output ,labels=[0,1,2,3,4] ,target_names =['N','S','V','F','Q']))